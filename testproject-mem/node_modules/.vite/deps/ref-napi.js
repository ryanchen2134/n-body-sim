import {
  require_fs,
  require_path
} from "./chunk-NBWAAJVH.js";
import {
  __commonJS,
  __require
} from "./chunk-VUNV25KB.js";

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "node_modules/node-gyp-build/node-gyp-build.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    var os = require_os();
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"]) dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release) return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug) return debug;
      }
      var prebuild = resolve(dir);
      if (prebuild) return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby) return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple) return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner) return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2) return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2) return;
      if (!architectures.length) return;
      if (!architectures.every(Boolean)) return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null) return false;
        if (tuple.platform !== platform2) return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node") return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null) return false;
        if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;
        if (tags.abi && tags.abi !== abi2 && !tags.napi) return false;
        if (tags.uv && tags.uv !== uv) return false;
        if (tags.armv && tags.armv !== armv) return false;
        if (tags.libc && tags.libc !== libc) return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron) return true;
      if (process.env.ELECTRON_RUN_AS_NODE) return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "node_modules/node-gyp-build/index.js"(exports, module) {
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    if (typeof runtimeRequire.addon === "function") {
      module.exports = runtimeRequire.addon.bind(runtimeRequire);
    } else {
      module.exports = require_node_gyp_build();
    }
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ref-napi/lib/ref.js
var require_ref = __commonJS({
  "node_modules/ref-napi/lib/ref.js"(exports, module) {
    var assert = require_assert();
    var inspect = require_util().inspect;
    var debug = require_browser()("ref");
    var os = require_os();
    var path = require_path();
    exports = module.exports = require_node_gyp_build2()(path.join(__dirname, ".."));
    exports.endianness = os.endianness();
    exports.refType = function refType(type) {
      const _type = exports.coerceType(type);
      const rtn = Object.create(_type);
      rtn.indirection++;
      if (_type.name) {
        Object.defineProperty(rtn, "name", {
          value: _type.name + "*",
          configurable: true,
          enumerable: true,
          writable: true
        });
      }
      return rtn;
    };
    exports.derefType = function derefType(type) {
      const _type = exports.coerceType(type);
      if (_type.indirection === 1) {
        throw new Error("Cannot create deref'd type for type with indirection 1");
      }
      let rtn = Object.getPrototypeOf(_type);
      if (rtn.indirection !== _type.indirection - 1) {
        rtn = Object.create(_type);
        rtn.indirection--;
      }
      return rtn;
    };
    exports.coerceType = function coerceType(type) {
      let rtn = type;
      if (typeof rtn === "string") {
        rtn = exports.types[type];
        if (rtn) return rtn;
        rtn = type.replace(/\s+/g, "").toLowerCase();
        if (rtn === "pointer") {
          rtn = exports.refType(exports.types.void);
        } else if (rtn === "string") {
          rtn = exports.types.CString;
        } else {
          var refCount = 0;
          rtn = rtn.replace(/\*/g, function() {
            refCount++;
            return "";
          });
          rtn = exports.types[rtn];
          if (refCount > 0) {
            if (!(rtn && "size" in rtn && "indirection" in rtn)) {
              throw new TypeError('could not determine a proper "type" from: ' + inspect(type));
            }
            for (let i = 0; i < refCount; i++) {
              rtn = exports.refType(rtn);
            }
          }
        }
      }
      if (!(rtn && "size" in rtn && "indirection" in rtn)) {
        throw new TypeError('could not determine a proper "type" from: ' + inspect(type));
      }
      return rtn;
    };
    exports.getType = function getType(buffer) {
      if (!buffer.type) {
        debug('WARN: no "type" found on buffer, setting default "type"', buffer);
        buffer.type = {};
        buffer.type.size = buffer.length;
        buffer.type.indirection = 1;
        buffer.type.get = function get() {
          throw new Error('unknown "type"; cannot get()');
        };
        buffer.type.set = function set() {
          throw new Error('unknown "type"; cannot set()');
        };
      }
      return exports.coerceType(buffer.type);
    };
    exports.get = function get(buffer, offset, type) {
      if (!offset) {
        offset = 0;
      }
      if (type) {
        type = exports.coerceType(type);
      } else {
        type = exports.getType(buffer);
      }
      debug("get(): (offset: %d)", offset, buffer);
      assert(type.indirection > 0, `"indirection" level must be at least 1, saw ${type.indirection}`);
      if (type.indirection === 1) {
        return type.get(buffer, offset);
      } else {
        const size = type.indirection === 2 ? type.size : exports.sizeof.pointer;
        const reference = exports.readPointer(buffer, offset, size);
        reference.type = exports.derefType(type);
        return reference;
      }
    };
    exports.set = function set(buffer, offset, value, type) {
      if (!offset) {
        offset = 0;
      }
      if (type) {
        type = exports.coerceType(type);
      } else {
        type = exports.getType(buffer);
      }
      debug("set(): (offset: %d)", offset, buffer, value);
      assert(type.indirection >= 1, '"indirection" level must be at least 1');
      if (type.indirection === 1) {
        type.set(buffer, offset, value);
      } else {
        exports.writePointer(buffer, offset, value);
      }
    };
    exports.alloc = function alloc(_type, value) {
      var type = exports.coerceType(_type);
      debug('allocating Buffer for type with "size"', type.size);
      let size;
      if (type.indirection === 1) {
        size = type.size;
      } else {
        size = exports.sizeof.pointer;
      }
      const buffer = Buffer.alloc(size);
      buffer.type = type;
      if (arguments.length >= 2) {
        debug("setting value on allocated buffer", value);
        exports.set(buffer, 0, value, type);
      }
      return buffer;
    };
    exports.allocCString = function allocCString(string, encoding) {
      if (null == string || Buffer.isBuffer(string) && exports.isNull(string)) {
        return exports.NULL;
      }
      const size = Buffer.byteLength(string, encoding) + 1;
      const buffer = Buffer.allocUnsafe(size);
      exports.writeCString(buffer, 0, string, encoding);
      buffer.type = charPtrType;
      return buffer;
    };
    exports.writeCString = function writeCString(buffer, offset, string, encoding) {
      assert(Buffer.isBuffer(buffer), "expected a Buffer as the first argument");
      assert.strictEqual("string", typeof string, 'expected a "string" as the third argument');
      if (!offset) {
        offset = 0;
      }
      if (!encoding) {
        encoding = "utf8";
      }
      const size = buffer.length - offset - 1;
      const len = buffer.write(string, offset, size, encoding);
      buffer.writeUInt8(0, offset + len);
    };
    exports["readInt64" + exports.endianness] = exports.readInt64;
    exports["readUInt64" + exports.endianness] = exports.readUInt64;
    exports["writeInt64" + exports.endianness] = exports.writeInt64;
    exports["writeUInt64" + exports.endianness] = exports.writeUInt64;
    var opposite = exports.endianness == "LE" ? "BE" : "LE";
    var int64temp = Buffer.alloc(exports.sizeof.int64);
    var uint64temp = Buffer.alloc(exports.sizeof.uint64);
    exports["readInt64" + opposite] = function(buffer, offset) {
      for (let i = 0; i < exports.sizeof.int64; i++) {
        int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1];
      }
      return exports.readInt64(int64temp, 0);
    };
    exports["readUInt64" + opposite] = function(buffer, offset) {
      for (let i = 0; i < exports.sizeof.uint64; i++) {
        uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1];
      }
      return exports.readUInt64(uint64temp, 0);
    };
    exports["writeInt64" + opposite] = function(buffer, offset, value) {
      exports.writeInt64(int64temp, 0, value);
      for (let i = 0; i < exports.sizeof.int64; i++) {
        buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1];
      }
    };
    exports["writeUInt64" + opposite] = function(buffer, offset, value) {
      exports.writeUInt64(uint64temp, 0, value);
      for (let i = 0; i < exports.sizeof.uint64; i++) {
        buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1];
      }
    };
    exports.ref = function ref(buffer) {
      debug("creating a reference to buffer", buffer);
      var type = exports.refType(exports.getType(buffer));
      return exports.alloc(type, buffer);
    };
    exports.deref = function deref(buffer) {
      debug("dereferencing buffer", buffer);
      return exports.get(buffer);
    };
    var kAttachedRefs = Symbol("attached");
    exports._attach = function _attach(buf, obj) {
      if (!buf[kAttachedRefs]) {
        buf[kAttachedRefs] = [];
      }
      buf[kAttachedRefs].push(obj);
    };
    exports.writeObject = function writeObject(buf, offset, obj) {
      debug("writing Object to buffer", buf, offset, obj);
      exports._writeObject(buf, offset, obj);
      exports._attach(buf, obj);
    };
    exports.writePointer = function writePointer(buf, offset, ptr) {
      debug("writing pointer to buffer", buf, offset, ptr);
      exports._writePointer(buf, offset, ptr, true);
    };
    exports.reinterpret = function reinterpret(buffer, size, offset) {
      debug('reinterpreting buffer to "%d" bytes', size);
      const rtn = exports._reinterpret(buffer, size, offset || 0);
      exports._attach(rtn, buffer);
      return rtn;
    };
    exports.reinterpretUntilZeros = function reinterpretUntilZeros(buffer, size, offset) {
      debug('reinterpreting buffer to until "%d" NULL (0) bytes are found', size);
      var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0);
      exports._attach(rtn, buffer);
      return rtn;
    };
    var types = exports.types = {};
    types.void = {
      size: 0,
      indirection: 1,
      get: function get(buf, offset) {
        debug("getting `void` type (returns `null`)");
        return null;
      },
      set: function set(buf, offset, val) {
        debug("setting `void` type (no-op)");
      }
    };
    types.int8 = {
      size: exports.sizeof.int8,
      indirection: 1,
      get: function get(buf, offset) {
        return buf.readInt8(offset || 0);
      },
      set: function set(buf, offset, val) {
        if (typeof val === "string") {
          val = val.charCodeAt(0);
        }
        return buf.writeInt8(val, offset || 0);
      }
    };
    types.uint8 = {
      size: exports.sizeof.uint8,
      indirection: 1,
      get: function get(buf, offset) {
        return buf.readUInt8(offset || 0);
      },
      set: function set(buf, offset, val) {
        if (typeof val === "string") {
          val = val.charCodeAt(0);
        }
        return buf.writeUInt8(val, offset || 0);
      }
    };
    types.int16 = {
      size: exports.sizeof.int16,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readInt16" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeInt16" + exports.endianness](val, offset || 0);
      }
    };
    types.uint16 = {
      size: exports.sizeof.uint16,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readUInt16" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeUInt16" + exports.endianness](val, offset || 0);
      }
    };
    types.int32 = {
      size: exports.sizeof.int32,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readInt32" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeInt32" + exports.endianness](val, offset || 0);
      }
    };
    types.uint32 = {
      size: exports.sizeof.uint32,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readUInt32" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeUInt32" + exports.endianness](val, offset || 0);
      }
    };
    types.int64 = {
      size: exports.sizeof.int64,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readInt64" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeInt64" + exports.endianness](val, offset || 0);
      }
    };
    types.uint64 = {
      size: exports.sizeof.uint64,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readUInt64" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeUInt64" + exports.endianness](val, offset || 0);
      }
    };
    types.float = {
      size: exports.sizeof.float,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readFloat" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeFloat" + exports.endianness](val, offset || 0);
      }
    };
    types.double = {
      size: exports.sizeof.double,
      indirection: 1,
      get: function get(buf, offset) {
        return buf["readDouble" + exports.endianness](offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf["writeDouble" + exports.endianness](val, offset || 0);
      }
    };
    types.Object = {
      size: exports.sizeof.Object,
      indirection: 1,
      get: function get(buf, offset) {
        return buf.readObject(offset || 0);
      },
      set: function set(buf, offset, val) {
        return buf.writeObject(val, offset || 0);
      }
    };
    types.CString = {
      size: exports.sizeof.pointer,
      alignment: exports.alignof.pointer,
      indirection: 1,
      get: function get(buf, offset) {
        const _buf = exports.readPointer(buf, offset);
        if (exports.isNull(_buf)) {
          return null;
        }
        return exports.readCString(_buf, 0);
      },
      set: function set(buf, offset, val) {
        let _buf;
        if (Buffer.isBuffer(val)) {
          _buf = val;
        } else {
          _buf = exports.allocCString(val);
        }
        return exports.writePointer(buf, offset, _buf);
      }
    };
    var utfstringwarned = false;
    Object.defineProperty(types, "Utf8String", {
      enumerable: false,
      configurable: true,
      get: function() {
        if (!utfstringwarned) {
          utfstringwarned = true;
          console.error('"Utf8String" type is deprecated, use "CString" instead');
        }
        return types.CString;
      }
    });
    [
      "bool",
      "byte",
      "char",
      "uchar",
      "short",
      "ushort",
      "int",
      "uint",
      "long",
      "ulong",
      "longlong",
      "ulonglong",
      "size_t"
    ].forEach((name) => {
      const unsigned = name === "bool" || name === "byte" || name === "size_t" || name[0] === "u";
      const size = exports.sizeof[name];
      assert(size >= 1 && size <= 8);
      let typeName = "int" + size * 8;
      if (unsigned) {
        typeName = "u" + typeName;
      }
      const type = exports.types[typeName];
      assert(type);
      exports.types[name] = Object.create(type);
    });
    Object.keys(exports.alignof).forEach((name) => {
      if (name === "pointer")
        return;
      exports.types[name].alignment = exports.alignof[name];
      assert(exports.types[name].alignment > 0);
    });
    exports.types.bool.get = /* @__PURE__ */ function(_get) {
      return function get(buf, offset) {
        return _get(buf, offset) ? true : false;
      };
    }(exports.types.bool.get);
    exports.types.bool.set = /* @__PURE__ */ function(_set) {
      return function set(buf, offset, val) {
        if (typeof val !== "number") {
          val = val ? 1 : 0;
        }
        return _set(buf, offset, val);
      };
    }(exports.types.bool.set);
    Object.keys(exports.types).forEach((name) => {
      exports.types[name].name = name;
    });
    var charPtrType = exports.refType(exports.types.char);
    exports.NULL.type = exports.types.void;
    exports.NULL_POINTER = exports.ref(exports.NULL);
    Buffer.prototype.address = function address() {
      return exports.address(this, 0);
    };
    Buffer.prototype.hexAddress = function hexAddress() {
      return exports.hexAddress(this, 0);
    };
    Buffer.prototype.isNull = function isNull() {
      return exports.isNull(this, 0);
    };
    Buffer.prototype.ref = function ref() {
      return exports.ref(this);
    };
    Buffer.prototype.deref = function deref() {
      return exports.deref(this);
    };
    Buffer.prototype.readObject = function readObject(offset) {
      return exports.readObject(this, offset);
    };
    Buffer.prototype.writeObject = function writeObject(obj, offset) {
      return exports.writeObject(this, offset, obj);
    };
    Buffer.prototype.readPointer = function readPointer(offset, size) {
      return exports.readPointer(this, offset, size);
    };
    Buffer.prototype.writePointer = function writePointer(ptr, offset) {
      return exports.writePointer(this, offset, ptr);
    };
    Buffer.prototype.readCString = function readCString(offset) {
      return exports.readCString(this, offset);
    };
    Buffer.prototype.writeCString = function writeCString(string, offset, encoding) {
      return exports.writeCString(this, offset, string, encoding);
    };
    Buffer.prototype.readInt64BE = function readInt64BE(offset) {
      return exports.readInt64BE(this, offset);
    };
    Buffer.prototype.writeInt64BE = function writeInt64BE(val, offset) {
      return exports.writeInt64BE(this, offset, val);
    };
    Buffer.prototype.readUInt64BE = function readUInt64BE(offset) {
      return exports.readUInt64BE(this, offset);
    };
    Buffer.prototype.writeUInt64BE = function writeUInt64BE(val, offset) {
      return exports.writeUInt64BE(this, offset, val);
    };
    Buffer.prototype.readInt64LE = function readInt64LE(offset) {
      return exports.readInt64LE(this, offset);
    };
    Buffer.prototype.writeInt64LE = function writeInt64LE(val, offset) {
      return exports.writeInt64LE(this, offset, val);
    };
    Buffer.prototype.readUInt64LE = function readUInt64LE(offset) {
      return exports.readUInt64LE(this, offset);
    };
    Buffer.prototype.writeUInt64LE = function writeUInt64LE(val, offset) {
      return exports.writeUInt64LE(this, offset, val);
    };
    Buffer.prototype.reinterpret = function reinterpret(size, offset) {
      return exports.reinterpret(this, size, offset);
    };
    Buffer.prototype.reinterpretUntilZeros = function reinterpretUntilZeros(size, offset) {
      return exports.reinterpretUntilZeros(this, size, offset);
    };
    var inspectSym = inspect.custom || "inspect";
    if (Buffer.prototype[inspectSym]) {
      Buffer.prototype[inspectSym] = overwriteInspect(Buffer.prototype[inspectSym]);
    }
    if (!(exports.NULL instanceof Buffer)) {
      debug("extending SlowBuffer's prototype since it doesn't inherit from Buffer.prototype");
      SlowBuffer = require_buffer().SlowBuffer;
      SlowBuffer.prototype.address = Buffer.prototype.address;
      SlowBuffer.prototype.hexAddress = Buffer.prototype.hexAddress;
      SlowBuffer.prototype.isNull = Buffer.prototype.isNull;
      SlowBuffer.prototype.ref = Buffer.prototype.ref;
      SlowBuffer.prototype.deref = Buffer.prototype.deref;
      SlowBuffer.prototype.readObject = Buffer.prototype.readObject;
      SlowBuffer.prototype.writeObject = Buffer.prototype.writeObject;
      SlowBuffer.prototype.readPointer = Buffer.prototype.readPointer;
      SlowBuffer.prototype.writePointer = Buffer.prototype.writePointer;
      SlowBuffer.prototype.readCString = Buffer.prototype.readCString;
      SlowBuffer.prototype.writeCString = Buffer.prototype.writeCString;
      SlowBuffer.prototype.reinterpret = Buffer.prototype.reinterpret;
      SlowBuffer.prototype.reinterpretUntilZeros = Buffer.prototype.reinterpretUntilZeros;
      SlowBuffer.prototype.readInt64BE = Buffer.prototype.readInt64BE;
      SlowBuffer.prototype.writeInt64BE = Buffer.prototype.writeInt64BE;
      SlowBuffer.prototype.readUInt64BE = Buffer.prototype.readUInt64BE;
      SlowBuffer.prototype.writeUInt64BE = Buffer.prototype.writeUInt64BE;
      SlowBuffer.prototype.readInt64LE = Buffer.prototype.readInt64LE;
      SlowBuffer.prototype.writeInt64LE = Buffer.prototype.writeInt64LE;
      SlowBuffer.prototype.readUInt64LE = Buffer.prototype.readUInt64LE;
      SlowBuffer.prototype.writeUInt64LE = Buffer.prototype.writeUInt64LE;
      if (SlowBuffer.prototype[inspectSym]) {
        SlowBuffer.prototype[inspectSym] = overwriteInspect(SlowBuffer.prototype[inspectSym]);
      }
    }
    var SlowBuffer;
    function overwriteInspect(inspect2) {
      if (inspect2.name === "refinspect") {
        return inspect2;
      } else {
        return function refinspect() {
          var v = inspect2.apply(this, arguments);
          return v.replace("Buffer", "Buffer@0x" + this.hexAddress());
        };
      }
    }
  }
});
export default require_ref();
/*! Bundled license information:

ref-napi/lib/ref.js:
  (*!
   * Set the `name` property of the types. Used for debugging...
   *)
  (*!
   * This `char *` type is used by "allocCString()" above.
   *)
  (*!
   * Set the `type` property of the `NULL` pointer Buffer object.
   *)
  (*!
   * SlowBuffer convenience methods.
   *)
*/
//# sourceMappingURL=ref-napi.js.map
