import {
  require_fs,
  require_path
} from "./chunk-NBWAAJVH.js";
import {
  __commonJS,
  __require
} from "./chunk-VUNV25KB.js";

// node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "node_modules/bindings/bindings.js"(exports, module) {
    var fs = require_fs();
    var path = require_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists = fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " â†’ ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      opts.__proto__ = defaults;
      if (!opts.module_root) {
        opts.module_root = exports.getRoot(exports.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(null, opts.try[i].map(function(p) {
          return opts[p] || p;
        }));
        tries.push(n);
        try {
          b = opts.path ? __require.resolve(n) : __require(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (!/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error("Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
        return opts.arrow + a;
      }).join("\n"));
      err.tries = tries;
      throw err;
    }
    module.exports = exports = bindings;
    exports.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      return fileName;
    };
    exports.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists(join(dir, "package.json")) || exists(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error('Could not find module root given file: "' + file + '". Do you have a `package.json` file? ');
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// node_modules/posix-semaphore/srcs/addon.js
var require_addon = __commonJS({
  "node_modules/posix-semaphore/srcs/addon.js"(exports, module) {
    var SemaphoreCPP = require_bindings()("addon").Semaphore;
    var semaphoreNames = {};
    function parseOptions(options) {
      if (typeof options !== "object") {
        options = {};
      }
      if (!(options.strict === false)) {
        options.strict = true;
      }
      if (!options.debug) {
        options.debug = false;
      } else {
        options.debug = true;
      }
      if (!options.silent) {
        options.silent = false;
      } else {
        options.silent = true;
      }
      if (!(options.retryOnEintr === true)) {
        options.retryOnEintr = false;
      }
      return options;
    }
    function registerExitHandler(options, onExit) {
      process.on("SIGINT", () => {
        setTimeout(() => {
          process.exit(0);
        }, 4e3);
        onExit();
        process.exit(0);
      });
      process.on("exit", onExit);
      process.on("uncaughtException", (err) => {
        console.error(err.stack);
        if (!options.silent || options.debug) {
          console.log("[posix-semaphore] Catched uncaughtException, closing semaphore if necessary...");
        }
        setTimeout(() => {
          process.exit(1);
        }, 4e3);
        onExit();
        process.exit(1);
      });
    }
    function Semaphore(name, options) {
      if (!(this instanceof Semaphore)) {
        return new Semaphore(name, options);
      }
      if (typeof name !== "string") {
        throw new Error("Semaphore() expects a string as first argument");
      }
      if (semaphoreNames[name] === 1) {
        throw new Error(`Semaphore "${name}" already open in this process`);
      }
      this.acquire = () => {
        this.sem.acquire();
      };
      this.release = () => {
        this.sem.release();
      };
      this.close = () => {
        this.sem.close();
        delete semaphoreNames[name];
        this.closed = true;
      };
      semaphoreNames[name] = 1;
      this.name = name;
      options = parseOptions(options);
      this.sem = new SemaphoreCPP(name, options.strict, options.debug, options.silent, options.retryOnEintr, options.value);
      if (options.closeOnExit === void 0 || options.closeOnExit) {
        const onExit = () => {
          if (this.closed !== true) {
            if (!options.silent || options.debug) {
              console.log(`[posix-semaphore] Exiting, closing semaphore "${this.name}"... (to prevent this behavior, set the 'closeOnExit' option to false)`);
            }
            this.close();
            if (!options.silent || options.debug) {
              console.log("[posix-semaphore] done.");
            }
          }
        };
        registerExitHandler(options, onExit);
      }
    }
    module.exports = Semaphore;
  }
});
export default require_addon();
//# sourceMappingURL=posix-semaphore.js.map
